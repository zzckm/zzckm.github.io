---
title: '线程'
date: 2019-03-25 23:00:40
tags: [线程]
---
# 线程

## **并行与并发**

> 程序在没有流程控制前提下，代码都是从上而下逐行执行的。

**并发**和**并行**是即相似又有区别(微观概念)：

并行
: 指两个或多个事件在**同一时刻点**发生

并发
: 指两个或多个事件在**同一时间段**内发生

在操作系统中，在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单CPU系统中，每一时刻却仅能有一道程序执行（时间片），故微观上这些程序只能是分时地交替执行。
倘若计算机系统中有多个CPU，则这些可以并发执行的程序便可被分配到多个处理器上，实现多任务并行执行，即利用每个处理器来处理一个可并发执行的程序，这样，多个程序便可以同时执行，因为是微观的，所以大家在使用电脑的时候感觉就是多个程序是同时执行的。
所以，大家买电脑的时候喜欢买“核”多的，其原因就是“多核处理器”电脑可以同时并行地处理多个程序，从而提高了电脑的运行效率。
单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。
同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。

**时间片**即CPU分配给各个程序的运行时间(很小的概念).

---

## **进程和线程**

进程
: 
**进程**是指一个内存中运行中的应用程序。每个进程都有自己独立的一块内存空间，一个应用程序可以同时启动多个进程。比如在Windows系统中，一个运行的abc.exe的程序就是一个进程。那么我们此时就可以处理同时玩游戏和听音乐的问题了，我们可以设计成两个程序，一个专门负责玩游戏，一个专门负责听音乐。
但是问题来了，要是要设计一个植物大战僵尸游戏，我得开N个进程才能完成多个功能，这样的设计显然是不合理的。
更何况大多数操作系统都不需要一个进程访问其他进程的内存空间，也就是说**进程之间的通信很不方便**。
此时我们得引入“**线程**”这门技术，来解决这个问题。

线程
: **线程**是指进程中的一个执行任务(控制单元)，一个进程可以同时并发运行多个线程，如：多线程下载软件。
多任务系统,该系统可以运行多个进程,一个进程也可以执行多个任务,一个进程可以包含多个线程.
一个进程至少有一个线程，为了提高效率，可以在一个进程中开启多个执行任务,即**多线程**。
**多进程**：操作系统中同时运行的多个程序。
**多线程**：在同一个进程中同时运行的多个任务。
在操作系统中允许多个任务，每一个任务就是一个进程，每一个进程也可以同时执行多个任务，每一个任务就是线程。

进程与线程的区别
: 
进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。
线程：堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的，又称为轻型进程或进程元。
因为一个进程中的多个线程是并发运行的，那么从微观角度上考虑也是有先后顺序的，那么哪个线程执行完全取决于CPU调度器(JVM来调度)，程序员是控制不了的。
我们可以把多线程并发性看作是多个线程在瞬间抢CPU资源，谁抢到资源谁就运行，这也造就了多线程的随机性。
**Java程序的进程**(Java的一个程序运行在系统中)里至少包含主线程和垃圾回收线程(后台线程)。

线程调度
: 计算机通常只有一个CPU时,在任意时刻只能执行一条计算机指令,每一个进程只有获得CPU的使用权才能执行指令.
所谓多进程并发运行,从宏观上看,其实是各个进程轮流获得CPU的使用权,分别执行各自的任务.
那么,在可运行池中,会有多个线程处于就绪状态等到CPU,JVM就负责了线程的调度.
JVM采用的是抢占式调度,没有采用分时调度,因此可以能造成多线程执行结果的的随机性。

多线程优势
: 多线程是为了同步完成多项任务，不是为了提供程序运行效率，而是通过**提高资源使用效率**来提高系统的效率。
> 宽带带宽是以位（bit）计算，而下载速度是以字节（Byte）计算，1字节（Byte）等于8位（bit），所以1024kb/s是代表上网带宽为1024千位（1M），而下载速度需要1024千位/秒（1024kb/s）带宽除以8，得出128千字节/秒（128KB/s）。

---

## **创建和启动线程**
方式1：继承Thread类
:  

 1. 定义一个类A继承于java.lang.Thread类.
 2. 在A类中覆盖Thread类中的run方法.
 3. 我们在run方法中编写需要执行的操作---->run方法里的,线程执行体.
 4. 在main方法(线程)中,创建线程对象,并启动线程.
        创建线程类对象: A类 a = new A类();
        调用线程对象的start方法: a.start();//启动一个线程

 **注意:**千万不要调用run方法,如果调用run方法好比是对象调用方法,依然还是只有一个线程,并没有开启新的线程.
 
方式2：实现Runnable接口
: 

  1. 定义一个类A实现于java.lang.Runnable接口,注意A类不是线程类.
  2. 在A类中覆盖Runnable接口中的run方法.
  3. 我们在run方法中编写需要执行的操作---->run方法里的,线程执行体.
  4. 在main方法(线程)中,创建线程对象,并启动线程.
     创建线程类对象: Thread t = new Thread(new A());    
     调用线程对象的start方法: t.start();

继承与接口方式的区别
: 

  1. 继承
    - Java中是单继承的，如果使用继承的方式，那么这个类就不能有其他的直接父类
    - 继承方式操作简单，获取线程的名字简单
    - 共享资源来说：继承方式不能简单的实现（可以通过间接继承麻烦的实现）
  2. 实现
    - Java中可以实现多个接口，此时该类还可以继承其他类，并且还可以实现其他接口（在设计上更为优雅）
    - 实现方式操作有点麻烦，获取线程的名字需要通过Thread.currentThread().getName()来获取
    - 可以共享同一个资源
    

## **线程同步**

解决方案
 :    当张羽执行-1的操作的时候，别人只能等待，等到张羽执行完毕，小周和小李才能继续执行
 1. 同步代码块
 2. 同步方法
 3. 锁机制（Lock）


同步代码块
: 语法
    ```java
        synchronized (同步锁) {
            需要同步操作的代码块
        }
        
    ```    
    
 1. 同步锁
    在java中为了保证每一个线程都能正常执行原子操作，Java引入了线程同步机制。
    同步监听对象/同步锁/同步监听器/互斥锁
    对象的同步锁都是一个概念，只是在需要共享的数据对象上标记一个锁。
    当前并发的时候需要访问的共享资源叫做同步监听对象。
    任何时候，Java只允许一个线程拥有同步锁

同步方法
: 语法
    synchronized public void print() 
    
    同步锁：
        对于非静态方法来说，同步锁就是this
        对于静态方法来说，同步锁就是字节码对象（Apple.class）
        
        
Lock锁
: Java 1.5之后出现的
 1. 为了取代 synchronized 代码块和同步方法
 2. 使用Condition接口对象的await()，signal(),signalAll()取代wait()，notify()，notifyAll()


避免死锁
: 当多个线程都要访问某些共享资源A,B,C,D时候，保证每一个线程都按照相同的顺序去访问，比如说先访问A,然后B,C,D

线程的生命周期
: 
 
 1. 新建
    new 的时候，在调用start方法之前，new Thread()
 2. 就绪
    start方法之后，等待JVM进行调用，分配资源
 3. 运行
    获取资源之后。
 4. 阻塞
    一般情况下，线程因为某些原因放弃CPU，暂时停止运行
    正在运行，需要获取同步锁的时候，但是这个锁被其他线程获取。
 5. 等待状态
    wait()，sleep()
 6. 死亡
    线程终止

  